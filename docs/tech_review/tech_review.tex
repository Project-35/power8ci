\documentclass[10pt,letterpaper,onecolumn,journal]{IEEEtran}
\usepackage[margin=0.75in]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{array}
\usepackage{booktabs}
\usepackage{hyperref}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  columns=flexible,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\begin{document}
\begin{titlepage}
  \title{POWER8 Continuous Integration Technology Review}
  \author{Leon Leighton, Thomas Olson, Derek Wong\\Project 35}
  \date{November 14, 2016}
  \maketitle
  \vspace{4cm}
  \begin{abstract}
  \noindent
  \end{abstract}
\end{titlepage}

\tableofcontents
\clearpage

\section{Cluster Management}
\subsection{Options}
\subsubsection{OpenStack}
OpenStack is a cluster management solution originally created by Rackspace and NASA, and now managed by the OpenStack Foundation.
It contains a number of projects that provide services such as object and block storage, identity management, networking and compute resource management, bare metal provisioning, and DNS services.
This modular approach allows users to select which parts they need to accomplish their goals without having to install components they will not be using.
\subsubsection{CloudStack}
CloudStack is an Apache Software Foundation cluster management project which aims to provide many of the same services as OpenStack.
It follows a more monolithic approach where most components are distributed as part of a single binary.
\subsubsection{Ganeti}
Ganeti is a cluster management solution from Google that focuses on managing virtual machines.
It can be used to create new virtual machines, manage disks, and manage failover of virtual machine instance.
\subsection{Goals for use}
The primary goal for using cluster management software is to manage the creation and destruction of temporary virtual machines and containers that will be used for building and testing projects.
\subsection{Criteria for Evaluation}
\begin{enumerate}
  \item Community Support: Our chosen solution should have a community that provides support in the form of documentation, bug fixes, and assistance.
  \item Linux Support: Linux must be supported as both host and guest.
  \item Container Support: Optional, but we would like to have support for building and testing in containers.
  \item Jenkins Plugin Support: Jenkins is a likely piece of our solution, therefore having Jenkins plugin that interacts with our cluster management solution is highly desired.
\end{enumerate}
\subsection{Table}
\begin{center}
  \begin{tabular}{llll}
    Criteria & OpenStack & CloudStack & Ganeti \\ \midrule
    Community Support       & Yes & Yes & Yes \\ \midrule
    Linux Support           & Yes & Yes & Yes \\ \midrule
    Container Support       & Yes & Partial & No \\ \midrule
    Jenkins Plugin Support  & Yes & Yes & No \\ \bottomrule
  \end{tabular}
\end{center}
\subsection{Discussion}
OpenStack, CloudStack, and Ganeti can all run on Linux and can host Linux virtual machines.
Ganeti does little more than this, however, and will not be considered further.
Both OpenStack and CloudStack can interact with Jenkins through a plugin.
OpenStack appears to have a larger community and a more mature container solution than CloudStack.
\subsection{Selection of best option}
OpenStack is our chosen solution for cluster management. It meets all of our criteria for evaluation.


\section{Continuous Integration Software}
\subsection{Options}
\subsubsection{Jenkins}
Jenkins is an automation server that can be used to automate builds, tests, and deployments.
It is extensible and has a large number of plugins that enable it to interact with other systems. 
\subsubsection{Buildbot}
Buildbot is another system that enables the automation of builds, tests, and deployments.
It can be extended through the use of Python configuration files. 
\subsubsection{Strider}
Strider is a continuous integration server written in Node.js.
Like Jenkins it uses plugins to extend its functionality.
\subsection{Goals for use}
Automate building and testing Open Source projects.
\subsection{Criteria for Evaluation}
\begin{enumerate}
  \item Language Support
  \item Code Repository Support
  \item 
\end{enumerate}
\subsection{Table}
\subsection{Discussion}
\subsection{Selection of best option}

\section{Linux Distribution Support}
\subsection{Options}
\subsubsection{RedHat Enterprise Linux}
RedHat Enterprise Linux is widely considered to be one of the standard Linux distributions for server environments, having been around for a number of years and being very stable. It is supported by the Red Had corporation and has a ten-year supported production cycle for each major version, followed by an extended support period\cite{rhlife}. Unlike most Linux distributions, it has a paid subscription requirement for support and the extended support has a higher price. However, as a paid product, Red Hat provides dedicated support and certifications which can be important if such certifications are required for a project or if the project requires high availability and dedicated support in case issues arise.
\subsubsection{CentOS}
CentOS is an unbranded version of RedHat Enterprise Linux, providing the same functionality and stability with only very minor functional differences. It is supported by the CentOS Project and is free for all use. As a result, it does not have the certifications nor the dedicated support of RedHat Enterprise Linux. As it tries to track the development of RedHat Enterprise Linux very closely, CentOS has approximately the same ten-year support cycle\cite{centlife}, but it does not have the same extended support period provided by Red Hat.
\subsubsection{Ubuntu Server}
Ubuntu Server is a version of the Ubuntu distribution that differs from the desktop version only by the installer and the life cycle\cite{ubuntulife}. It is supported by Canonical and has a five-year life cycle per major version. Like CentOS, it is free to use, but Canonical optionally offers a contract for dedicated support. Ubuntu also tends to update application packages sooner, trading some amount of stability for newer functionality.
\subsection{Goals for use}
The operating system  selection will have a major effect on the stability and ease-of-use of the entire system. Our goal is to select an operating system that is stable, widely supported and easy to work with.
\subsection{Criteria for Evaluation}
\begin{enumerate}
  \item Stability: It is important that the operating system used for running builds has as few issues as possible so as to minimize the need for manual intervention in case there's a failure.
  \item Support: The operating system should have a strong support base to maximize ease of maintenance and help ensure longevity.
  \item Usability: The greater the usability and ease of configuration, the easier it becomes to maintain and improve the reliability of the system.
  \item Cost: The less the entire system costs, the better. Additionally, 
\end{enumerate}
\subsection{Table}
\begin{center}
  \begin{tabular}{llll}
    Criteria & RedHat & CentOS & Ubuntu Server \\ \midrule
    Stability       & Highest & High & Moderate \\ \midrule
    Support           & Highest & Moderate & Moderate \\ \midrule
    Usability       & High & High & High \\ \midrule
    Cost       & High & None & None \\ \bottomrule
  \end{tabular}
\end{center}
\subsection{Discussion}
As this project does not require high availability or dedicated support, the benefits of buying a subscription for Red Hat Enterprise Linux and negligible, especially being that CentOS has much of the same functionality and the same length support cycle. This project also does not require an operating system that provides newer functionalities sooner like Ubuntu does, stability being a more important requirement.
\subsection{Selection of best option}
We have opted for using CentOS as the operating system that builds will be ran on and tested against. It provides the necessary stability and a wide base of support with a ten-year life cycle, while also being easy to configure, deploy and maintain.

\section{Configuration Management}
\subsection{Options}
\subsubsection{Ansible}
Ansible is a configuration management and infrastructure automation solution.
It is agentless and uses YAML files for configuration.  
\subsubsection{Chef}
Chef is a configuration management solution.
It uses agents running on each server to poll a central server to access configuration `cookbooks' that are written in a Ruby based DSL\@.
\subsubsection{Puppet}
Puppet it also a configuration management solution.
Like Chef, it uses agents and configuration is done in a Ruby based DSL\@.
\subsection{Goals for use}
\subsection{Criteria for Evaluation}
\begin{enumerate}
  \item
  \item
\end{enumerate}
\subsection{Table}
\subsection{Discussion}
\subsection{Selection of best option}

\section{Platform for Running Builds}
\subsection{Options}
\subsubsection{Virtual Machine}
Virtual Machines perform hardware-level emulation and do not allow the guests any access to the underlying operating system or hardware. They're the standard for situations where multiple OS's need to be deployed. Because they emulate all the hardware, there's nearly no risk of a malicious guest system affecting the host system. However, running a virtual machine requires a full operating system to be installed on each individual instance, causing them to take up a relatively significant amount of space per virtual machine compared to to size of the applications running on them. Additionally, their performance suffers due to having to emulate assembly-level instructions instead of executing them directly.
\subsubsection{Container}
Containers perform operating system virtualization, allowing for multiple independent user-spaces to exist at the same time. Because they emulate parts of the operating system and not the physical hardware hardware, containers still need to allow some level of direct hardware access for applications to run properly. They also use some libraries provided by the host operating system instead of providing their own. As a result, they tend to be much smaller than a full-fledged virtual machine and run somewhat faster. A relatively new technology compared to virtual machines, they're rapidly gaining popularity in situations where hardware emulation is not required and restricting access to the host operating system is not a concern.
\subsubsection{Bare metal}
Bare metal servers would have no virtualization or emulation; builds and tests would be ran directly on the hardware itself. The benefits to bare metal are speed and security; no emulation layer exists between the applications and the hardware and there is no host operating system for a malicious guest to interfere with. Builds would also be unable to hoard system resources, preventing a situation where one build slows down another. The single major downside is the requirement for a full physical server per each build that would be ran, greatly restricting the ability for multiple builds to be ran in parallel
\subsection{Goals for use}
The goal of selecting the platform the builds would interact with is to allow builds a host system to be ran and tested on while providing reliability and security for the underlying system.
\subsection{Criteria for Evaluation}
\begin{enumerate}
  \item Scalability: Ideally, it should be easy to scale the system up to allow a large number of simultaneous builds.
  \item Performance: Our selection should not significantly decrease the performance of the build-test process.
  \item Security: Being that we will compiling and testing untrusted and unverified code, it is important for the selected platform to minimize the ability of the build to negatively affect the host.
  \item Reliability: It is preferable that one build does not use up so many resources as to significantly reduce the speed of other builds being ran.
\end{enumerate}
\subsection{Table}
\begin{center}
  \begin{tabular}{llll}
    Criteria & Virtual Machines & Containers & Bare metal \\ \midrule
    Scalability       & High & Highest & Low \\ \midrule
    Performance           & Moderate & High & Highest \\ \midrule
    Security       & High & Moderate & Highest \\ \midrule
    Reliability  & High & High & Highest \\ \bottomrule
  \end{tabular}
\end{center}
\subsection{Discussion}
Although bare metal servers have undeniably the best performance, security and reliability, they simply do not have the scalability required for a project like this. Depending on storage space and resources, virtual machines and containers could potentially run upwards of one hundred builds simultaneously on a single server, negating the performance benefits. Furthermore, virtual machines provide nearly the same level of security and safety that a bare metal server provides, while containers can nearly match them in terms of performance.

Between virtual machines and containers, virtual machines provide better security and have years of support behind them, while containers provide better performance; virtual machines can have a performance penalty upwards of ten percent due to overhead.\cite{RC25482} Both virtual machines and containers allow for limiting the resources provided to a running instance, meeting the reliability requirements. They are also both exceedingly easy to configure for automated deployment, making them highly scalable.
\subsection{Selection of best option}
Although virtual machines can have a noticeable performance penalty due to overhead, this can be reduced with proper tuning. Furthermore, we believe that the better isolation and security provided by virtual machines can easily outweigh the performance penalties. Therefore, we have decided that virtual machines are the ideal platform for running the builds and tests on.

\section{Configuration File Formats}
\subsection{Options}
\subsubsection{YAML}
\subsubsection{JSON}
\subsubsection{XML}
\subsection{Goals for use}
The configuration file will be included in a Git repository and will be how the system determines builds and tests are ran and interpreted. It should use a format powerful enough to accurately express all the information that the system will require without being unnecessarily complicated.
\subsection{Criteria for Evaluation}
\begin{enumerate}
  \item Expressiveness: The file format needs to be able to sufficiently express the users needs for building and testing their project.
  \item Readability: The ideal file format will be easy for a user to create and modify to suit the needs of their project.
\end{enumerate}
\subsection{Discussion}
\subsection{Selection of best option}

\section{Login/Authentication}
\subsection{Options}
\begin{enumerate}
  \item Google Login Plugin
  \item Active Directory Plugin
  \item Jenkins Login
\end{enumerate}
\subsection{Goals for use}
The goal for having an authentication is to provide our users a safe and secure place to build their project and to use our continuous integration service.
It will help prevent hackers from obtaining private information that could be detrimental to our users.
This is a security measure that is absolutely necessary for our project.
\subsection{Criteria for Evaluation}
The main criteria to look for in this technology is security.
Security is what keeps users confidential information such as source code from being leaked.
\subsection{Table}
\subsection{Discussion}
The google login plugin is a really straight forward method for authentication.
Users can simply use their google accounts to login.
This method requires an OAuth 2.0 credentials from the Google Developers Console and there are clear instructions on the internet to accomplish this task~\cite{googlelogin}.
The second option is to use the active directory plugin.
This plugin is used with Jenkins to authenticate the username and password through active directory~\cite{activedirectory}.
The third option is to use Jenkins’ login.
Users can simply create a Jenkins’ account and have access to its functionalities.
They will also have the ability to give authorizations to different accounts for their projects.
\subsection{Selection of best option}
The best option is to use Jenkins’ login.
We intend to build our continuous integration service project on a POWER8 architecture using a Jenkins backend; the most reasonable approach is to use Jenkins’ own login system.

\section{Frontend/Web frameworks}
\subsection{Options}
\begin{enumerate}
  \item Tomcat
  \item Glassfish
  \item Jetty
\end{enumerate}
\subsection{Goals for use}
The goal for having a web framework is so that our users have a platform to use our continuous integration service.
We will provide a simple and easy to use user interface (UI) so that our users would not have a complicated time using our services.
\subsection{Criteria for Evaluation}
The criteria in this technology are load time, usability, security, and stability.
Having an easy-to-use user interface can give our users an easy time to use our service and it will help reduce confusion.
The page load time should load at a reasonable speed so that our users would not have to wait a long time using our service.
Security is important for our web framework because we don’t want hackers to gain access to our services.
In order to provide our users a good experience, we need a secure environment.
Having good stability is important as well.
Our service need to maintain at a functional state at all time so that it doesn’t hinder our users from working.
\subsection{Table}
\subsection{Discussion}
Tomcat is very popular and it is known as a lightweight application that offers all the basic features required running a server.
It is an open source project so it is cost free.
It is highly flexible because it allows users to tweak their code as they see fit, and it has many built-in features~\cite{tomcat}.
The second option is Glassfish and it is also an open source project, which means that it is free of cost.
It has high performance and it was considered the fastest open source application server, according to SPECjAppServer2004 benchmark results~\cite{glassfish}.
Jetty provides a Web server and javax.servlet container.
They have a heavy focus on multi-connection HTTP and features such as SPYDY, which can significantly reduce page load latencies~\cite{jetty}.
\subsection{Selection of best option}
Overall, all three of the options are great, but the best option to use is Tomcat.
Glassfish has a lot of features and is the biggest out of the three options, but we are only using it for our frontend, so most features are unnecessary.
It has a big memory footprint, which means that it would consume more resources.
Jetty is a very light application and it consumes the least amount of resources but it is too small for our project.
Tomcat is ideal because it sits in between these two options and it offers a good amount of features to use.

\section{Tracing State of builds/tests}
\subsection{Options}
\begin{enumerate}
  \item Build Monitor Plugin
  \item Lava Lamp Notifier
  \item Radiator View Plugin
\end{enumerate}
\subsection{Goals for use}
The goal to having the functionality to trace the build and test state is so that our users can see the status of their projects.
This will reveal the success or failure of projects that were build by our service and it will show where the failures have occurred.
\subsection{Criteria for Evaluation}
The criteria to look for in this technology are usability, feature to display pass or fail builds, feature to display progress of builds, and feature to display where the error has occurred for build fails.
Having an easy-to-use user interface (UI) allows our users to operate our service with minimal issues.
The ability to display pass or fail build is the main criteria for this technology so this is a must have.
The feature to display progress when building a project is helpful for our users to see how much longer it will take until the build is complete.
The feature to see where an error has occurred in the build process is another important criteria; it will help developers save time from manually tracking down the problem.
\subsection{Table}
\subsection{Discussion}
The build monitor plugin supports many features and incorporates other plugins as well.
The features in this plugin include:
\begin{itemize}
  \item Displays the status and progress of selected jobs, the view is updated automatically every couple of seconds using AJAX\@. No `Enable Auto Refresh' needed.
  \item Displays the names of people who might be responsible for `breaking the build'.
  \item Supports the Claim plugin, so that you can see who's fixing a broken build.
  \item Supports View Job Filters, so that you can easily create Build Monitors for `slow builds', `only failing', etc.
  \item Supports Build Failure Analyzer, so that you know not only who, but also what broke the build.
  \item Supports CloudBees Folders Plugin, so that you can have project- and team-specific nested Build Monitors.
  \item The number of columns and size of the font used is easily customizable, making it trivial to accommodate screens of different sizes.
  \item UI configuration is stored in a cookie, making it possible to display different number of columns and using different font size on each of the screens at your office.
  \item Can work in a colour-blind-friendly mode
  \item~\cite{buildmonitor}
\end{itemize}
The lava lamp notifier is a really simple design created to indicate if a build passed or fail.
The only necessary component to use this type of method to track our build status is a USB LED light.
The light will simply light up green for pass and red for fail~\cite{lavalamp}.
This is not ideal for our type of project because our users would like to know more information than just a pass or fail notification.
The third option is the radiator view plugin.
This plugin is somewhat similar to the build monitor plugin but with less features.
It will display all the project that are building and indicate pass or fails on screen~\cite{radiatorview}.
\subsection{Selection of best option}
The best option to use is the build monitor plugin.
This technology has the most features out of all the other options I listed, and all the features are very useful for our users.

\bibliographystyle{IEEEtran}
\bibliography{tech_review}
\end{document}
